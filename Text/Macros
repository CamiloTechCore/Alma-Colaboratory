/**
 * @OnlyCurrentDoc
 * Se ejecuta cuando se abre la hoja de c√°lculo y crea los men√∫s personalizados.
 */
function onOpen() {
  var ui = SpreadsheetApp.getUi();

  // Primer men√∫ para la carga y consolidaci√≥n de datos (solo Consolidador)
  ui.createMenu('üíö Cargar Datos')
      .addItem('Consolidar C√≥digos Ahora', 'consolidarDatosEnBaseDatos')
      .addToUi();

  // Nuevo men√∫ para la transferencia de datos
  ui.createMenu('üíö Transferir datos') // Nuevo men√∫
      .addItem('Copiar ME_View a Base_Datos (sin duplicados)', 'copiarDatosME_ViewABase_Datos') // Texto actualizado
      .addToUi();

  // Segundo men√∫ para las herramientas de limpieza
  ui.createMenu('‚ùå Borrar datos')
      .addItem('Limpiar Datos (Reglas Espec√≠ficas)', 'limpiarDatosEspecificos')
      .addToUi();
}

/**
 * Consolida datos √∫nicos de la columna A de varias hojas fuente en la hoja 'ME_View'.
 * ESTA VERSI√ìN EST√Å OPTIMIZADA para mayor velocidad utilizando getRangeList.
 *
 * La funci√≥n no borra los datos existentes, sino que agrega solo los valores nuevos
 * y no repetidos al final de la columna A, sin dejar filas vac√≠as.
 */
function consolidarDatosEnBaseDatos() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const nombreHojaDestino = 'ME_View';
  const hojasFuenteNombres = [
    'FBM', 'DISTRIBUCION', 'PRE_DESPACHO', 'REDES',
    'KANGU', 'VIAJE_DEL_PAQUETE', 'NESTING'
  ];

  try {
    const hojaDestino = ss.getSheetByName(nombreHojaDestino);
    if (!hojaDestino) {
      SpreadsheetApp.getUi().alert(`Error: La hoja de destino '${nombreHojaDestino}' no fue encontrada.`);
      return;
    }

    // --- 1. Lee los c√≥digos que YA EXISTEN en MP_View para evitar duplicados ---
    const lastRowExistente = hojaDestino.getLastRow();
    const existingValuesSet = new Set();
    if (lastRowExistente >= 2) {
      const rangoExistente = hojaDestino.getRange("A2:A" + lastRowExistente).getValues();
      for (const fila of rangoExistente) {
        if (fila[0] && fila[0].toString().trim() !== "") {
          existingValuesSet.add(fila[0].toString().trim());
        }
      }
    }

    // --- 2. NUEVA L√ìGICA: Procesar cada hoja fuente UNA POR UNA ---
    const nuevosValoresParaAgregar = [];
    const processedInThisRunSet = new Set(); // Evita duplicados entre las hojas fuente

    for (const nombreHoja of hojasFuenteNombres) {
      const hojaFuente = ss.getSheetByName(nombreHoja);

      // Verifica que la hoja exista y tenga datos m√°s all√° del encabezado
      if (hojaFuente && hojaFuente.getLastRow() > 1) {
        console.log(`Procesando hoja: ${nombreHoja}`);
        
        // Lee los datos directamente de esta hoja
        const rangoFuente = hojaFuente.getRange("A2:A" + hojaFuente.getLastRow());
        const valoresFuente = rangoFuente.getValues();

        // Procesa los valores de esta hoja inmediatamente
        for (const fila of valoresFuente) {
          const valorCelda = fila[0];
          if (valorCelda && valorCelda.toString().trim() !== "") {
            const valorStr = valorCelda.toString().trim();

            // El filtro principal sigue siendo el mismo:
            // No debe existir en MP_View Y no debe haber sido a√±adido ya en esta ejecuci√≥n
            if (!existingValuesSet.has(valorStr) && !processedInThisRunSet.has(valorStr)) {
              nuevosValoresParaAgregar.push([valorStr]); // Lo a√±ade a la lista para escribir
              processedInThisRunSet.add(valorStr);      // Lo "recuerda" para no volver a a√±adirlo
            }
          }
        }
      } else {
        console.warn(`Se omite la hoja '${nombreHoja}' por no existir o estar vac√≠a.`);
      }
    }

    // --- 3. Escribe los nuevos datos al final de la columna A en MP_View (sin cambios aqu√≠) ---
    if (nuevosValoresParaAgregar.length > 0) {
      const filaParaEmpezarAEscribir = lastRowExistente + 1;
      hojaDestino.getRange(filaParaEmpezarAEscribir, 1, nuevosValoresParaAgregar.length, 1).setValues(nuevosValoresParaAgregar);
      SpreadsheetApp.getUi().alert(`Proceso completado. Se agregaron ${nuevosValoresParaAgregar.length} valores √∫nicos a la hoja '${nombreHojaDestino}'.`);
    } else {
      SpreadsheetApp.getUi().alert(`No se encontraron datos nuevos en las hojas fuente para agregar.`);
    }

  } catch (e) {
    // A√±adimos un bloque try-catch para capturar cualquier otro posible error y dar m√°s detalles
    console.error(`Ocurri√≥ un error inesperado: ${e.message}\n${e.stack}`);
    SpreadsheetApp.getUi().alert(`Se produjo un error. Detalles: ${e.message}`);
  }
}

/**
 * Valida y copia solo los registros nuevos de la hoja "ME_View"
 * a la hoja "Base_Datos" en un libro de c√°lculo externo,
 * utilizando "Interacci√≥n" como clave primaria para evitar duplicados.
 * No elimina la informaci√≥n ya existente en la hoja de destino.
 * ESTA VERSI√ìN EST√Å OPTIMIZADA para escritura masiva de datos.
 */
function copiarDatosME_ViewABase_Datos() {
  const SPREADSHEET_ID_DESTINO = "1hKAO_VX98a6SzR1FA9EIQXD6iPmre6x_PY80QhiB6zU";
  const NOMBRE_HOJA_ORIGEN = "ME_View";
  const NOMBRE_HOJA_DESTINO = "Base_Datos";
  const NOMBRE_COLUMNA_ID = "Interacci√≥n";

  try {
    // --- 1. Obtener datos de la hoja de origen (esto ya es eficiente) ---
    const libroActual = SpreadsheetApp.getActiveSpreadsheet();
    const hojaOrigen = libroActual.getSheetByName(NOMBRE_HOJA_ORIGEN);

    if (!hojaOrigen) {
      SpreadsheetApp.getUi().alert(`Error: La hoja "${NOMBRE_HOJA_ORIGEN}" no se encontr√≥.`);
      return;
    }

    const rangoOrigen = hojaOrigen.getDataRange(); // getDataRange() es m√°s robusto que getLastRow/Column
    const datosOrigen = rangoOrigen.getValues();

    if (datosOrigen.length < 2) { // Necesitamos encabezado y al menos una fila de datos
      SpreadsheetApp.getUi().alert(`La hoja "${NOMBRE_HOJA_ORIGEN}" no contiene datos para copiar.`);
      return;
    }

    const encabezadosOrigen = datosOrigen.shift(); // Extrae el encabezado y deja solo los datos
    const indiceColumnaID = encabezadosOrigen.indexOf(NOMBRE_COLUMNA_ID);

    if (indiceColumnaID === -1) {
      SpreadsheetApp.getUi().alert(`Error: La columna "${NOMBRE_COLUMNA_ID}" no se encontr√≥ en la hoja "${NOMBRE_HOJA_ORIGEN}".`);
      return;
    }

    // --- 2. Abrir el libro de destino y obtener IDs existentes (esto ya es eficiente) ---
    const libroDestino = SpreadsheetApp.openById(SPREADSHEET_ID_DESTINO);
    const hojaDestino = libroDestino.getSheetByName(NOMBRE_HOJA_DESTINO);

    if (!hojaDestino) {
      SpreadsheetApp.getUi().alert(`Error: La hoja "${NOMBRE_HOJA_DESTINO}" no se encontr√≥ en el libro de destino.`);
      return;
    }

    const idsExistentesEnDestino = new Set();
    const ultimaFilaDestino = hojaDestino.getLastRow();
    
    if (ultimaFilaDestino === 0) {
      // Si la hoja de destino est√° vac√≠a, a√±ade el encabezado
      hojaDestino.appendRow(encabezadosOrigen);
    } else {
      const encabezadosDestino = hojaDestino.getRange(1, 1, 1, hojaDestino.getLastColumn()).getValues()[0];
      const indiceColumnaIDDestino = encabezadosDestino.indexOf(NOMBRE_COLUMNA_ID);

      if (indiceColumnaIDDestino === -1) {
        SpreadsheetApp.getUi().alert(`Error: La columna "${NOMBRE_COLUMNA_ID}" no se encontr√≥ en la hoja de destino "${NOMBRE_HOJA_DESTINO}".`);
        return;
      }
      
      if (ultimaFilaDestino >= 2) {
        const rangoIDsDestino = hojaDestino.getRange(2, indiceColumnaIDDestino + 1, ultimaFilaDestino - 1, 1).getValues();
        rangoIDsDestino.forEach(row => {
          if (row[0]) idsExistentesEnDestino.add(row[0].toString().trim());
        });
      }
    }

    // --- 3. Filtrar los datos en memoria para obtener solo los registros nuevos (esto ya es eficiente) ---
    const nuevosRegistrosParaAgregar = datosOrigen.filter(fila => {
      const idOrigen = fila[indiceColumnaID];
      return idOrigen && idOrigen.toString().trim() !== "" && !idsExistentesEnDestino.has(idOrigen.toString().trim());
    });
    
    // --- 4. OPTIMIZACI√ìN: Escribir TODOS los registros nuevos en una sola operaci√≥n ---
    if (nuevosRegistrosParaAgregar.length > 0) {
      const filaParaEmpezarAEscribir = hojaDestino.getLastRow() + 1;
      const numFilas = nuevosRegistrosParaAgregar.length;
      const numColumnas = nuevosRegistrosParaAgregar[0].length;
      
      // Define el rango de destino y escribe todos los datos de una vez
      hojaDestino.getRange(filaParaEmpezarAEscribir, 1, numFilas, numColumnas).setValues(nuevosRegistrosParaAgregar);
      
      SpreadsheetApp.getUi().alert(`√âxito: Se agregaron ${nuevosRegistrosParaAgregar.length} registros nuevos a la hoja "${NOMBRE_HOJA_DESTINO}".`);
    } else {
      SpreadsheetApp.getUi().alert(`No se encontraron registros nuevos para agregar a la hoja "${NOMBRE_HOJA_DESTINO}".`);
    }

  } catch (error) {
    SpreadsheetApp.getUi().alert(`Se produjo un error: ${error.message}. Detalles: ${error.stack}`);
  }
}